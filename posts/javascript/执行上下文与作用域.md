---
title: "执行上下文&作用域"
text: "JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”,js 代码执行时，都是在这样的环境中执行的，执行时创建，执行完便销毁。"
category: "javascript,js"
date: "2019-10-27"
---

## 执行上下文

> JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”

js 代码执行时，都是在这样的环境中执行的，执行时创建，执行完便销毁。

执行上下文类型：

- 全局执行上下文：默认或者基础的上下文，任何不在函数内部的代码都存在于全局执行上下文中，他会创建一个 window（global）的全局对象，并将 this 赋予这个全局对象。一个程序将会只包含一个全局执行上下文
- 函数执行上下文：函数在被调用时创建的一个上下文，是这个函数拥有的属于其自己的上下文；该种上下文可以有多个，因为会存在有多个函数被调用，当函数被释放（调用完/销毁）后，其上下文也会被释放
- Eval 执行上下文：eval 函数内部代码也拥有一个执行上下文

---

## 执行栈

> 用来存储和管理 js 代码执行时创建的执行上下文的一种数据结构。

执行栈有着后进先出的原则。
js 引擎在执行 js 代码时，会创建一个全局执行上下文并压入执行栈，每当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈，直到执行完所有的代码，最后弹出全局执行上下文。其中，当分配的执行栈空间被占满时，会引发“堆栈溢出”。

---

## 创建执行上下文

执行上下文包括：

- lexical environment：词法环境，储存函数声明、const 和 let 声明的变量和 this 值
- variable environment：变量环境，储存 var 声明的变量

知道怎么管理执行上下文，就应该知道执行上下文是怎么创建的，创建执行上下文会发生以下几件事：

- 创建词法环境组件
- 创建变量环境组件

### 词法环境

> 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

简单理解就是一种键值对的映射，能够存储变量和函数声明的实际位置（代码中的位置），并有一个属性 outer，作为访问父级词法环境的标示（作用域），及一个 ThisBinding 属性，记录当前的 this 引用

根据执行上下文，词法环境也可以分为：

- 全局词法环境：outer 属性为 null，拥有内建的各种构造函数（Object、Array 等）、原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且`this`的值指向全局对象。
- 函数词法环境：函数内部用户自定义的变量或者函数，outer 为全局词法环境或者包含该函数的函数环境，this 在创建时指向其引用

### 变量环境

变量环境也是一种词法环境，但是在 ES6 之后，和词法环境不同的是，变量环境只是用来存储 var 声明的变量

举个例子

```js
var a = "a";
let b = "b";
const c = "c";

function A() {
  var d = "d";
  let e = "e";
  const f = "f";
  function B() {}
}

A();
```

根据这段代码，写一个伪代码来表示词法环境和变量环境的形式：
js 引擎要执行 js 代码，先创建全局执行上下文，并创建对应的词法环境和变量环境，压入执行栈，引擎开始执行相关代码，当遇到`A()`时，创建函数 A 的执行上下文，也创建对应的词法和变量环境，压入执行栈，并开始执行该函数

![执行栈](http://singz72.com/images/blog/context.png)

---

## 作用域链

作用域就是变量和函数的可访问区域，即作用域控制着变量和函数的可见性和生命周期。

作用域包括：

- 全局作用域
- 函数作用域
- 块级作用域

每个执行上下文都有一个属性 outer，来指向它外部的执行上下文，在我们执行一段 js 代码时，需要使用某个变量或者函数时，就会在当前执行上下文中寻找该变量或者函数，那么如果在当前的环境中没能找到对应的变量或者函数，就需要从他的外部执行上下文寻找，直到最外层为 null。其中存在着上下文的切换，我们是靠所在当前上下文的 outer 属性来决定方向的，而 outer 指向的便是外层上下文，这个方向，便是作用域链的方向。

举个例子

```js
const a = 1;

function A() {
  const b = 2;
  const c = a + b;
  B();
}

function B() {
  const d = 3;
  console.log(a + d);
  console.log(c);
}

A();
```

大概执行思路如下：

1. 执行 js 代码，创建全局上下文，压入执行栈，直到 A 函数被调用
2. 创建 A 函数的执行上下文，压入执行栈列表

   ```js
   执行栈列表：
   - global
   - A()
   ```

3. 执行 A 函数中所有代码：
   1. 在变量 c 的初始化过程中，需要获取 a 的值
   2. 从当前上下文中寻求 a 的值
   3. 未能找到 a 的值，读取 outer 属性值切换上下文，进入 outer 指向的上下文
   4. 在外层上下文中获取到 a 的值，返回自己的上下文
4. 代码执行到 B()
5. 创建 B 函数的执行上下文，压入执行栈列表

   ```js
   执行栈列表：
   - global
   - A()
   - B()
   ```

6. 执行 B 函数中所有代码，直到全部执行完毕：
   1. 获取 a 的变量
   2. 从当前上下文中寻求 a 的值
   3. 未能找到 a 的值，读取 outer 属性值切换上下文，进入 outer 指向的上下文
   4. 在外层上下文中获取到 a 的值，返回自己的上下文
   5. 获取 c 的变量
   6. 重复寻求 a 变量的步骤
   7. 在外层上下文中未能获取到 c 的值，读取外层上下文 outer 属性值切换上下文，但因为外层上下文的 outer 为 null，停止切换
   8. 未能成功获取到 c 的值，报错，停止代码的执行
7. 假设 B 函数成功执行完毕，从执行栈中删除 B()

   ```js
   执行栈列表：
   - global
   - A()
   ```

8. 返回 A 函数，执行 B()后的代码，直到全部执行完毕
9. 从执行栈中删除 A()

   ```js
   执行栈列表：
   - global
   ```

10. 返回到调用 A()的代码行，继续执行其后的代码，直到执行完毕
11. 删除全局上下文
12. 清空执行栈

![执行栈](http://singz72.com/images/blog/scope.png)

所以，可以理解得到，作用域的块儿和他的外部环境由在编写程序时的位置决定的，其中的切换上下文是按照作用域链的顺序来查找的，而不是按照执行栈由外到里的顺序来的

---

## 闭包

闭包就是函数和函数内部能访问到的变量的总和

通过闭包，我们能够隐藏变量，还能访问不能访问到的作用域

---

## this

不管函数从哪里被调用，也不论它是如何被调用，它的词法作用域是由这个函数被声明时的位置唯一决定的

ps：关于 this 的指向，在函数定义时是确定不了 this 的指向的，只能确定他的作用域，this 的指向是由该函数被调用时决定的，可以理解为，谁最终调用函数，this 指向谁

1. 调用函数时使用的引用，决定了函数执行时刻的 this 值。
2. this 指向的，永远只可能是对象
3. 通过函数名()直接调用，不论所在作用域是什么，该被调用 this 都指向 window
4. 箭头函数没有 thisbinding 属性

判定 this 方法：

1. 函数是通过 new 被调用的吗（new 绑定）

   如果是，this 就是新构建的实例对象，且无法改动。

   ```js
   var bar = new foo(); //bar
   ```

2. 函数是通过 call 或 apply 被调用的么（明确绑定），甚至是隐藏在 bind 硬绑定之中吗？

   如果是，this 就是那个被明确指定的对象。

   ```js
   var bar = foo.call(obj2); //obj2
   ```

3. 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。

   ```js
   var bar = obj1.foo(); //obj1
   ```

4. 否则，使用默认的 this。如果在 strict mode 下，就是 undefined，否则就是 global 对象。

   ```js
   var bar = foo(); //window
   ```

5. 箭头函数

   箭头函数中使用的 this 由包裹该箭头函数所处的环境决定（包裹箭头函数的非箭头函数）

   ```js
   const func1 = function () {
     const func2 = () => {
       console.log(this.name); //FUNC
     };
     setTimeout(func2, 1000);
   };
   func1.call({ name: "FUNC" });
   const obj = {
     a: "obj",
     f: () => {
       console.log(this);
     },
   };
   const func3 = obj.f;
   func3(); //window
   ```
